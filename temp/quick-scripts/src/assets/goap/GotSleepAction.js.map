{"version":3,"sources":["assets\\goap\\GotSleepAction.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA,4DAA2D;AAI3D,+DAA8D;AAC9D,kDAA6C;AAC7C,uDAAsD;AAGtD;IAAoC,kCAAU;IAK7C;QAAA,YACC,iBAAO,SAIP;QATO,WAAK,GAAY,KAAK,CAAA;QACtB,eAAS,GAAW,CAAC,CAAC;QACtB,kBAAY,GAAW,CAAC,CAAC,CAAC,UAAU;QACrC,UAAI,GAAW,CAAC,CAAA;QAGtB,KAAI,CAAC,eAAe,CAAC,mCAAgB,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC,CAAC,4BAA4B;QACrF,KAAI,CAAC,eAAe,CAAC,mCAAgB,CAAC,YAAY,EAAE,KAAK,CAAC,CAAC,CAAC,4BAA4B;QACxF,KAAI,CAAC,SAAS,CAAC,mCAAgB,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;;IACrD,CAAC;IAEM,8BAAK,GAAZ;QACC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC;IACpB,CAAC;IAEM,+BAAM,GAAb;QACC,OAAO,IAAI,CAAC,KAAK,CAAC;IACnB,CAAC;IAEM,wCAAe,GAAtB;QACC,OAAO,IAAI,CAAC;IACb,CAAC;IACM,oDAA2B,GAAlC,UAAmC,KAAgB;QAClD,IAAI,CAAC,MAAM,GAAG,yBAAW,CAAC,WAAW,CAAC;QACtC,OAAO,IAAI,CAAC,MAAM,IAAI,IAAI,CAAA;QAC1B,iDAAiD;QACjD,sDAAsD;QACtD,qCAAqC;QACrC,+BAA+B;QAE/B,4BAA4B;QAC5B,0BAA0B;QAC1B,uCAAuC;QACvC,oBAAoB;QACpB,8CAA8C;QAC9C,YAAY;QACZ,yCAAyC;QACzC,mDAAmD;QACnD,8BAA8B;QAC9B,sCAAsC;QACtC,qBAAqB;QACrB,yBAAyB;QACzB,MAAM;QACN,KAAK;QACL,IAAI;QACJ,uBAAuB;QACvB,iBAAiB;QAEjB,yBAAyB;QAEzB,0BAA0B;IAC3B,CAAC;IAEM,gCAAO,GAAd,UAAe,KAAgB;QAC9B,IAAI,IAAI,CAAC,SAAS,IAAI,CAAC;YACtB,IAAI,CAAC,SAAS,GAAG,kBAAQ,CAAC,OAAO,EAAE,CAAC;QAErC,IAAI,kBAAQ,CAAC,OAAO,EAAE,GAAG,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,YAAY,EAAE;YAC5D,wDAAwD;YACxD,IAAI,CAAC,KAAK,GAAG,IAAI,CAAA;SACjB;QACD,OAAO,IAAI,CAAC;IACb,CAAC;IACF,qBAAC;AAAD,CAjEA,AAiEC,CAjEmC,uBAAU,GAiE7C;AAjEY,wCAAc","file":"","sourceRoot":"/","sourcesContent":["import { GoapAction } from \"../src/app/ai/goap/GoapAction\";\r\nimport { GoapAgent } from \"../src/app/ai/goap/GoapAgent\";\r\nimport { IGoap } from \"../src/app/ai/goap/IGoap\";\r\nimport { VGameObject } from \"../src/app/base/VGameObject\";\r\nimport { Environment } from \"../src/app/gamedata/Environment\";\r\nimport TimeUtil from \"../src/utils/TimeUtil\";\r\nimport { ActionDataStatus } from \"./ActionDataStatus\";\r\nimport Entity from \"./Entity\";\r\n\r\nexport class GotSleepAction extends GoapAction {\r\n\tprivate bDone: boolean = false\r\n\tprivate startTime: number = 0;\r\n\tprivate workDuration: number = 1; // seconds\r\n\tpublic cost: number = 1\r\n\tpublic constructor() {\r\n\t\tsuper();\r\n\t\tthis.addPrecondition(ActionDataStatus.isTolietOk, true); // we need a tool to do this\r\n\t\tthis.addPrecondition(ActionDataStatus.isCanOutfire, false); // we need a tool to do this\r\n\t\tthis.addEffect(ActionDataStatus.isCanOutfire, true);\r\n\t}\r\n\r\n\tpublic reset(): void {\r\n\t\tthis.bDone = false;\r\n\t\tthis.startTime = 0;\r\n\t}\r\n\r\n\tpublic isDone() {\r\n\t\treturn this.bDone;\r\n\t}\r\n\r\n\tpublic requiresInRange() {\r\n\t\treturn true;\r\n\t}\r\n\tpublic checkProceduralPrecondition(agent: GoapAgent): boolean {\r\n\t\tthis.target = Environment.sleepTarget;\r\n\t\treturn this.target != null\r\n\t\t// // TODO:find the nearest tree that we can chop\r\n\t\t// let trees: TreeComponent[] = Environment.treeComps;\r\n\t\t// let closest: TreeComponent = null;\r\n\t\t// let closestDist: number = 0;\r\n\r\n\t\t// for (let tree of trees) {\r\n\t\t// \tif (closest == null) {\r\n\t\t// \t\t// first one, so choose it for now\r\n\t\t// \t\tclosest = tree;\r\n\t\t// \t\tclosestDist = tree.distanceSquare(agent);\r\n\t\t// \t} else {\r\n\t\t// \t\t// is this one closer than the last?\r\n\t\t// \t\tlet dist: number = tree.distanceSquare(agent);\r\n\t\t// \t\tif (dist < closestDist) {\r\n\t\t// \t\t\t// we found a closer one, use it\r\n\t\t// \t\t\tclosest = tree;\r\n\t\t// \t\t\tclosestDist = dist;\r\n\t\t// \t\t}\r\n\t\t// \t}\r\n\t\t// }\r\n\t\t// if (closest == null)\r\n\t\t// \treturn false;\r\n\r\n\t\t// this.target = closest;\r\n\r\n\t\t// return closest != null;\r\n\t}\r\n\r\n\tpublic perform(agent: GoapAgent): boolean {\r\n\t\tif (this.startTime == 0)\r\n\t\t\tthis.startTime = TimeUtil.getTime();\r\n\r\n\t\tif (TimeUtil.getTime() - this.startTime > this.workDuration) {\r\n\t\t\t//entity.memory.set(ActionDataStatus.isCanOutfire, true)\r\n\t\t\tthis.bDone = true\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n}"]}