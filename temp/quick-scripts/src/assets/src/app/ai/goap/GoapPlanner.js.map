{"version":3,"sources":["assets/src/app/ai/goap/GoapPlanner.ts"],"names":[],"mappings":";;;;;AAAA;;;;;;GAMG;;;AAOH;;GAEG;AACH;IAAA;IA8IA,CAAC;IA7IA;;;;OAIG;IACI,0BAAI,GAAX,UAAY,KAAY,EAAE,gBAA8B,EAAE,UAAqC,EAAE,IAA+B;QAC/H,IAAI,QAAQ,GAAa,KAAiB,CAAC;QAC3C,oDAAoD;QACpD,KAAc,UAAgB,EAAhB,qCAAgB,EAAhB,8BAAgB,EAAhB,IAAgB,EAAE;YAA3B,IAAI,CAAC,yBAAA;YACT,CAAC,CAAC,OAAO,EAAE,CAAC;SACZ;QAED,qEAAqE;QACrE,IAAI,aAAa,GAAiB,EAAE,CAAC;QACrC,KAAc,UAAgB,EAAhB,qCAAgB,EAAhB,8BAAgB,EAAhB,IAAgB,EAAE;YAA3B,IAAI,CAAC,yBAAA;YACT,IAAI,CAAC,CAAC,2BAA2B,CAAC,QAAoB,CAAC,EAAE;gBACxD,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;aACtB;SACD;QAED,gEAAgE;QAEhE,mFAAmF;QACnF,IAAI,MAAM,GAAe,EAAE,CAAC;QAE5B,cAAc;QACd,IAAI,KAAK,GAAa,IAAI,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,UAAU,EAAE,IAAI,CAAC,CAAC;QAC9D,IAAI,OAAO,GAAY,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,MAAM,EAAE,aAAa,EAAE,IAAI,CAAC,CAAC;QAE3E,IAAI,CAAC,OAAO,EAAE;YACb,8BAA8B;YAC9B,yBAAyB;YACzB,OAAO,IAAI,CAAC;SACZ;QAED,wBAAwB;QACxB,IAAI,QAAQ,GAAa,IAAI,CAAC;QAC9B,KAAiB,UAAM,EAAN,iBAAM,EAAN,oBAAM,EAAN,IAAM,EAAE;YAApB,IAAI,IAAI,eAAA;YACZ,IAAI,QAAQ,IAAI,IAAI,EAAE;gBACrB,QAAQ,GAAG,IAAI,CAAC;aAChB;iBAAM;gBACN,IAAI,IAAI,CAAC,WAAW,GAAG,QAAQ,CAAC,WAAW,EAAE;oBAC5C,QAAQ,GAAG,IAAI,CAAC;iBAChB;aACD;SACD;QAED,iDAAiD;QACjD,IAAI,MAAM,GAAiB,EAAE,CAAC;QAC9B,IAAI,CAAC,GAAa,QAAQ,CAAC;QAC3B,OAAO,CAAC,IAAI,IAAI,EAAE;YACjB,IAAI,CAAC,CAAC,MAAM,IAAI,IAAI,EAAE;gBACrB,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;aACtB;YACD,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC;SACb;QACD,MAAM,CAAC,OAAO,EAAE,CAAC;QAEjB,yBAAyB;QACzB,OAAO,MAAM,CAAC;IACf,CAAC;IACD;;OAEG;IACK,kCAAY,GAApB,UAAqB,OAAqB,EAAE,QAAoB;QAC/D,IAAI,MAAM,GAAiB,EAAE,CAAC;QAC9B,KAAc,UAAO,EAAP,mBAAO,EAAP,qBAAO,EAAP,IAAO,EAAE;YAAlB,IAAI,CAAC,gBAAA;YACT,IAAI,CAAC,IAAI,QAAQ,EAAE;gBAClB,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;aACf;SACD;QACD,OAAO,MAAM,CAAC;IACf,CAAC;IAED;;;;;OAKG;IACK,gCAAU,GAAlB,UAAmB,MAAgB,EAAE,MAAkB,EAAE,aAA2B,EAAE,IAA+B;QACpH,IAAI,QAAQ,GAAY,KAAK,CAAC;QAE9B,8EAA8E;QAC9E,KAAmB,UAAa,EAAb,+BAAa,EAAb,2BAAa,EAAb,IAAa,EAAE;YAA7B,IAAI,MAAM,sBAAA;YACd,6FAA6F;YAC7F,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,aAAa,EAAE,MAAM,CAAC,KAAK,CAAC,EAAE;gBACrD,iDAAiD;gBACjD,IAAI,YAAY,GAA8B,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,OAAO,CAAC,CAAC;gBAC/F,IAAI,IAAI,GAAa,IAAI,QAAQ,CAAC,MAAM,EAAE,MAAM,CAAC,WAAW,GAAG,MAAM,CAAC,IAAI,EAAE,YAAY,EAAE,MAAM,CAAC,CAAC;gBAElG,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,YAAY,CAAC,EAAE;oBACrC,uBAAuB;oBACvB,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;oBAClB,QAAQ,GAAG,IAAI,CAAC;iBAChB;qBAAM;oBACN,mFAAmF;oBAEnF,IAAI,MAAM,GAAiB,IAAI,CAAC,YAAY,CAAC,aAAa,EAAE,MAAM,CAAC,CAAC;oBAEpE,IAAI,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,MAAM,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;oBACxD,IAAI,KAAK,EAAE;wBACV,QAAQ,GAAG,IAAI,CAAC;qBAChB;iBACD;aACD;SACD;QAED,OAAO,QAAQ,CAAC;IACjB,CAAC;IAED;;;OAGG;IACK,6BAAO,GAAf,UAAgB,IAA+B,EAAE,KAAgC;QAChF,IAAI,UAAU,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;QACzC,KAAgB,UAAU,EAAV,yBAAU,EAAV,wBAAU,EAAV,IAAU,EAAE;YAAvB,IAAI,GAAG,mBAAA;YACX,IAAI,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;gBACpC,OAAO,KAAK,CAAC;aACb;SACD;QACD,OAAO,IAAI,CAAC;IACb,CAAC;IAED;;OAEG;IACK,mCAAa,GAArB,UAAsB,YAAuC,EAAE,WAAsC;QACpG,IAAI,KAAK,GAA8B,IAAI,GAAG,EAAwB,CAAC;QACvE,oCAAoC;QACpC,YAAY,CAAC,OAAO,CAAC,UAAC,KAAa,EAAE,GAAiB;YACrD,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;QACvB,CAAC,CAAC,CAAA;QAEF,WAAW,CAAC,OAAO,CAAC,UAAC,KAAa,EAAE,GAAiB;YACpD,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;QACvB,CAAC,CAAC,CAAA;QAEF,OAAO,KAAK,CAAC;IACd,CAAC;IACF,kBAAC;AAAD,CA9IA,AA8IC,IAAA;AA9IY,kCAAW;AAgJxB;IAMC,kBAAY,MAAgB,EAAE,WAAmB,EAAE,KAAgC,EAAE,MAAkB;QACtG,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;QAC/B,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;IACtB,CAAC;IACF,eAAC;AAAD,CAZA,AAYC,IAAA;AAZY,4BAAQ","file":"","sourceRoot":"/","sourcesContent":["/*\n * @Description: \n * @Author: RannarYang \n * @Date: 2018-09-06 00:09:35 \n * @Last Modified by: RannarYang\n * @Last Modified time: 2018-11-04 18:04:36\n */\n\nimport { Labourer } from \"../../gamedata/labourers/Labourer\";\nimport { ActionStatus } from \"./ActionStatus\";\nimport { GoapAction } from \"./GoapAction\";\nimport { IGoap } from \"./IGoap\";\n\n/**\n * Plans what actions can be completed in order to fulfill a goal state.\n */\nexport class GoapPlanner {\n\t/**\n\t * Plan what sequence of actions can fulfill the goal.\n\t * Returns null if a plan could not be found, or a list of the actions\n\t * that must be performed, in order, to fulfill the goal.\n\t */\n\tpublic plan(iGoap: IGoap, availableActions: GoapAction[], worldState: Map<ActionStatus, Object>, goal: Map<ActionStatus, Object>): GoapAction[] {\n\t\tlet labourer: Labourer = iGoap as Labourer;\n\t\t// reset the actions so we can start fresh with them\n\t\tfor (let a of availableActions) {\n\t\t\ta.doReset();\n\t\t}\n\n\t\t// check what actions can run using their checkProceduralPrecondition\n\t\tlet usableActions: GoapAction[] = [];\n\t\tfor (let a of availableActions) {\n\t\t\tif (a.checkProceduralPrecondition(labourer as Labourer)) {\n\t\t\t\tusableActions.push(a);\n\t\t\t}\n\t\t}\n\n\t\t// we now have all actions that can run, stored in usableActions\n\n\t\t// build up the tree and record the leaf nodes that provide a solution to the goal.\n\t\tlet leaves: PlanNode[] = [];\n\n\t\t// build graph\n\t\tlet start: PlanNode = new PlanNode(null, 0, worldState, null);\n\t\tlet success: boolean = this.buildGraph(start, leaves, usableActions, goal);\n\n\t\tif (!success) {\n\t\t\t// oh no, we didn't get a plan\n\t\t\t//console.log(\"NO PLan\");\n\t\t\treturn null;\n\t\t}\n\n\t\t// get the cheapest leaf\n\t\tlet cheapest: PlanNode = null;\n\t\tfor (let leaf of leaves) {\n\t\t\tif (cheapest == null) {\n\t\t\t\tcheapest = leaf;\n\t\t\t} else {\n\t\t\t\tif (leaf.runningCost < cheapest.runningCost) {\n\t\t\t\t\tcheapest = leaf;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// get its node and work back through the parents\n\t\tlet result: GoapAction[] = [];\n\t\tlet n: PlanNode = cheapest;\n\t\twhile (n != null) {\n\t\t\tif (n.action != null) {\n\t\t\t\tresult.push(n.action);\n\t\t\t}\n\t\t\tn = n.parent;\n\t\t}\n\t\tresult.reverse();\n\n\t\t// hooray we have a plan!\n\t\treturn result;\n\t}\n\t/**\n\t * Create a subset of the actions excluding the removeMe one. Creates a new set.\n\t */\n\tprivate actionSubset(actions: GoapAction[], removeMe: GoapAction): GoapAction[] {\n\t\tlet subset: GoapAction[] = [];\n\t\tfor (let a of actions) {\n\t\t\tif (a != removeMe) {\n\t\t\t\tsubset.push(a);\n\t\t\t}\n\t\t}\n\t\treturn subset;\n\t}\n\n\t/**\n\t * Returns true if at least one solution was found.\n\t * The possible paths are stored in the leaves list. Each leaf has a\n\t * 'runningCost' value where the lowest cost will be the best action\n\t * sequence.\n\t */\n\tprivate buildGraph(parent: PlanNode, leaves: PlanNode[], usableActions: GoapAction[], goal: Map<ActionStatus, Object>): boolean {\n\t\tlet foundOne: boolean = false;\n\n\t\t// go through each action available at this node and see if we can use it here\n\t\tfor (let action of usableActions) {\n\t\t\t// if the parent state has the conditions for this action's preconditions, we can use it here\n\t\t\tif (this.inState(action.Preconditions, parent.state)) {\n\t\t\t\t// apply the action's effects to the parent state\n\t\t\t\tlet currentState: Map<ActionStatus, Object> = this.populateState(parent.state, action.Effects);\n\t\t\t\tlet node: PlanNode = new PlanNode(parent, parent.runningCost + action.cost, currentState, action);\n\n\t\t\t\tif (this.inState(goal, currentState)) {\n\t\t\t\t\t// we found a solution!\n\t\t\t\t\tleaves.push(node);\n\t\t\t\t\tfoundOne = true;\n\t\t\t\t} else {\n\t\t\t\t\t// not at a solution yet, so test all the remaining actions and branch out the tree\n\n\t\t\t\t\tlet subset: GoapAction[] = this.actionSubset(usableActions, action);\n\n\t\t\t\t\tlet found = this.buildGraph(node, leaves, subset, goal);\n\t\t\t\t\tif (found) {\n\t\t\t\t\t\tfoundOne = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn foundOne;\n\t}\n\n\t/**\n\t * Check that all items in 'test' are in 'state'. If just one does not match or is not there\n\t * then this returns false.\n\t */\n\tprivate inState(test: Map<ActionStatus, Object>, state: Map<ActionStatus, Object>): boolean {\n\t\tlet testKeyArr = Array.from(test.keys());\n\t\tfor (let key of testKeyArr) {\n\t\t\tif (test.get(key) != state.get(key)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Apply the stateChange to the currentState\n\t */\n\tprivate populateState(currentState: Map<ActionStatus, Object>, stateChange: Map<ActionStatus, Object>): Map<ActionStatus, Object> {\n\t\tlet state: Map<ActionStatus, Object> = new Map<ActionStatus, Object>();\n\t\t// copy the KVPs over as new objects\n\t\tcurrentState.forEach((value: Object, key: ActionStatus) => {\n\t\t\tstate.set(key, value);\n\t\t})\n\n\t\tstateChange.forEach((value: Object, key: ActionStatus) => {\n\t\t\tstate.set(key, value);\n\t\t})\n\n\t\treturn state;\n\t}\n}\n\nexport class PlanNode {\n\tpublic parent: PlanNode;\n\tpublic runningCost: number;\n\tpublic state: Map<ActionStatus, Object>;\n\tpublic action: GoapAction;\n\n\tconstructor(parent: PlanNode, runningCost: number, state: Map<ActionStatus, Object>, action: GoapAction) {\n\t\tthis.parent = parent;\n\t\tthis.runningCost = runningCost;\n\t\tthis.state = state;\n\t\tthis.action = action;\n\t}\n}"]}