{"version":3,"sources":["assets/src/app/ai/goap/GoapPlanner.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"/","sourcesContent":["import { ActionStatus } from \"./ActionStatus\"\nimport { GoapAction } from \"./GoapAction\"\n\n/**\n * Plans what actions can be completed in order to fulfill a goal state.\n */\nexport class GoapPlanner {\n    /**\n     * Plan what sequence of actions can fulfill the goal.\n     * Returns null if a plan could not be found, or a list of the actions\n     * that must be performed, in order, to fulfill the goal.\n     */\n    public plan(go: cc.Node, availableActions: GoapAction[], worldState: Map<ActionStatus, Object>, goal: Map<ActionStatus, Object>): GoapAction[] {\n        // reset the actions so we can start fresh with them\n        for (let a of availableActions) {\n            a.doReset()\n        }\n\n        // check what actions can run using their checkProceduralPrecondition\n        let usableActions: GoapAction[] = []\n        for (let a of availableActions) {\n            if (a.checkProceduralPrecondition(go)) {\n                usableActions.push(a)\n            }\n        }\n\n        // we now have all actions that can run, stored in usableActions\n\n        // build up the tree and record the leaf nodes that provide a solution to the goal.\n        let leaves: PlanNode[] = []\n\n        // build graph\n        let start: PlanNode = new PlanNode(null, 0, worldState, null)\n        let success: boolean = this.buildGraph(start, leaves, usableActions, goal)\n\n        if (!success) {\n            // oh no, we didn't get a plan\n            //console.log(\"NO PLan\");\n            return null\n        }\n\n        // get the cheapest leaf\n        let cheapest: PlanNode = null\n        for (let leaf of leaves) {\n            if (cheapest == null) {\n                cheapest = leaf\n            } else {\n                if (leaf.runningCost < cheapest.runningCost) {\n                    cheapest = leaf\n                }\n            }\n        }\n\n        // get its node and work back through the parents\n        let result: GoapAction[] = []\n        let n: PlanNode = cheapest\n        while (n != null) {\n            if (n.action != null) {\n                result.push(n.action)\n            }\n            n = n.parent\n        }\n        result.reverse()\n\n        // hooray we have a plan!\n        return result\n    }\n    /**\n     * Create a subset of the actions excluding the removeMe one. Creates a new set.\n     */\n    private actionSubset(actions: GoapAction[], removeMe: GoapAction): GoapAction[] {\n        let subset: GoapAction[] = []\n        for (let a of actions) {\n            if (a != removeMe) {\n                subset.push(a)\n            }\n        }\n        return subset\n    }\n\n    /**\n     * Returns true if at least one solution was found.\n     * The possible paths are stored in the leaves list. Each leaf has a\n     * 'runningCost' value where the lowest cost will be the best action\n     * sequence.\n     */\n    private buildGraph(parent: PlanNode, leaves: PlanNode[], usableActions: GoapAction[], goal: Map<ActionStatus, Object>): boolean {\n        let foundOne: boolean = false\n\n        // go through each action available at this node and see if we can use it here\n        for (let action of usableActions) {\n            // if the parent state has the conditions for this action's preconditions, we can use it here\n            if (this.inState(action.preconditions, parent.state)) {\n                // apply the action's effects to the parent state\n                let currentState: Map<ActionStatus, Object> = this.populateState(parent.state, action.effects)\n                let node: PlanNode = new PlanNode(parent, parent.runningCost + action.cost, currentState, action)\n\n                if (this.inState(goal, currentState)) {\n                    // we found a solution!\n                    leaves.push(node)\n                    foundOne = true\n                } else {\n                    // not at a solution yet, so test all the remaining actions and branch out the tree\n\n                    let subset: GoapAction[] = this.actionSubset(usableActions, action)\n\n                    let found = this.buildGraph(node, leaves, subset, goal)\n                    if (found) {\n                        foundOne = true\n                    }\n                }\n            }\n        }\n\n        return foundOne\n    }\n\n    /**\n     * Check that all items in 'test' are in 'state'. If just one does not match or is not there\n     * then this returns false.\n     */\n    private inState(test: Map<ActionStatus, Object>, state: Map<ActionStatus, Object>): boolean {\n        let testKeyArr = Array.from(test.keys())\n        for (let key of testKeyArr) {\n            if (test.get(key) != state.get(key)) {\n                return false\n            }\n        }\n        return true\n    }\n\n    /**\n     * Apply the stateChange to the currentState\n     */\n    private populateState(currentState: Map<ActionStatus, Object>, stateChange: Map<ActionStatus, Object>): Map<ActionStatus, Object> {\n        let state: Map<ActionStatus, Object> = new Map<ActionStatus, Object>()\n        // copy the KVPs over as new objects\n        currentState.forEach((value: Object, key: ActionStatus) => {\n            state.set(key, value)\n        })\n\n        stateChange.forEach((value: Object, key: ActionStatus) => {\n            state.set(key, value)\n        })\n\n        return state\n    }\n}\n\nexport class PlanNode {\n    public parent: PlanNode\n    public runningCost: number\n    public state: Map<ActionStatus, Object>\n    public action: GoapAction\n\n    constructor(parent: PlanNode, runningCost: number, state: Map<ActionStatus, Object>, action: GoapAction) {\n        this.parent = parent\n        this.runningCost = runningCost\n        this.state = state\n        this.action = action\n    }\n}\n"]}