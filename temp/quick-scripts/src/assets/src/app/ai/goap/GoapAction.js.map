{"version":3,"sources":["assets/src/app/ai/goap/GoapAction.ts"],"names":[],"mappings":";;;;;;;AAMA;;;;;;GAMG;AACH;IAkBI;QAdQ,YAAO,GAAY,KAAK,CAAA;QAEhC;;8BAEsB;QACf,SAAI,GAAW,CAAC,CAAA;QAUnB,IAAI,CAAC,cAAc,GAAG,IAAI,GAAG,EAAwB,CAAA;QACrD,IAAI,CAAC,QAAQ,GAAG,IAAI,GAAG,EAAwB,CAAA;IACnD,CAAC;IAEM,4BAAO,GAAd;QACI,IAAI,CAAC,OAAO,GAAG,KAAK,CAAA;QACpB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAA;QAClB,IAAI,CAAC,KAAK,EAAE,CAAA;IAChB,CAAC;IA+BD;;;OAGG;IACI,8BAAS,GAAhB;QACI,OAAO,IAAI,CAAC,OAAO,CAAA;IACvB,CAAC;IAEM,+BAAU,GAAjB,UAAkB,OAAgB;QAC9B,IAAI,CAAC,OAAO,GAAG,OAAO,CAAA;IAC1B,CAAC;IAEM,oCAAe,GAAtB,UAAuB,GAAW,EAAE,KAAU;QAC1C,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAA;IACvC,CAAC;IAEM,uCAAkB,GAAzB,UAA0B,GAAW;QACjC,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA;IACnC,CAAC;IAEM,8BAAS,GAAhB,UAAiB,GAAW,EAAE,KAAU;QACpC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAA;IACjC,CAAC;IAEM,iCAAY,GAAnB,UAAoB,GAAW;QAC3B,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA;IAC7B,CAAC;IAED,sBAAW,qCAAa;aAAxB;YACI,OAAO,IAAI,CAAC,cAAc,CAAA;QAC9B,CAAC;;;OAAA;IAED,sBAAW,+BAAO;aAAlB;YACI,OAAO,IAAI,CAAC,QAAQ,CAAA;QACxB,CAAC;;;OAAA;IACL,iBAAC;AAAD,CA7FA,AA6FC,IAAA;AA7FqB,gCAAU","file":"","sourceRoot":"/","sourcesContent":["import Entity from \"../../../../goap/Entity\"\nimport { VGameObject } from \"../../base/VGameObject\"\nimport { ActionStatus } from \"./ActionStatus\"\nimport { GoapAgent } from \"./GoapAgent\"\nimport { IGoap } from \"./IGoap\"\n\n/*\n * @Description:\n * @Author: RannarYang\n * @Date: 2018-09-06 00:09:26\n * @Last Modified by:   RannarYang\n * @Last Modified time: 2018-09-06 00:09:26\n */\nexport abstract class GoapAction {\n    private _preconditions: Map<ActionStatus, Object>\n    private _effects: Map<ActionStatus, Object>\n\n    private inRange: boolean = false\n\n    /* 执行动作的成本。\n     * 找出适合动作的重量。\n     * 更改它将影响在计划期间选择的操作。*/\n    public cost: number = 1\n\n    /**\n     * 一个动作通常必须在一个对象上执行。这就是那个对象。可以为空。 */\n    public target: VGameObject\n\n    // 动作所属\n    public goapAgent: GoapAgent\n\n    public constructor() {\n        this._preconditions = new Map<ActionStatus, Object>()\n        this._effects = new Map<ActionStatus, Object>()\n    }\n\n    public doReset() {\n        this.inRange = false\n        this.target = null\n        this.reset()\n    }\n    /**\n     * Reset any variables that need to be reset before planning happens again.\n     */\n    abstract reset(): void\n\n    /**\n     * Is the action done?\n     */\n    abstract isDone(): boolean\n\n    /**\n     * Procedurally check if this action can run. Not all actions\n     * will need this, but some might.\n     */\n    abstract checkProceduralPrecondition(node:cc.Node): boolean\n\n    /**\n     * Run the action.\n     * Returns True if the action performed successfully or false\n     * if something happened and it can no longer perform. In this case\n     * the action queue should clear out and the goal cannot be reached.\n     */\n    abstract perform(goap: cc.Node): boolean\n\n    /**\n     * Does this action need to be within range of a target game object?\n     * If not then the moveTo state will not need to run for this action.\n     */\n    abstract requiresInRange(): boolean\n\n    /**\n     * Are we in range of the target?\n     * The MoveTo state will set this and it gets reset each time this action is performed.\n     */\n    public isInRange(): boolean {\n        return this.inRange\n    }\n\n    public setInRange(inRange: boolean): void {\n        this.inRange = inRange\n    }\n\n    public addPrecondition(key: string, value: any) {\n        this._preconditions.set(key, value)\n    }\n\n    public removePrecondition(key: string) {\n        this._preconditions.delete(key)\n    }\n\n    public addEffect(key: string, value: any) {\n        this._effects.set(key, value)\n    }\n\n    public removeEffect(key: string) {\n        this._effects.delete(key)\n    }\n\n    public get preconditions() {\n        return this._preconditions\n    }\n\n    public get effects() {\n        return this._effects\n    }\n}\n"]}