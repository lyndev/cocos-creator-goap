{"version":3,"sources":["assets\\src\\app\\ai\\goap\\GoapAction.ts"],"names":[],"mappings":";;;;;;;AAMA;;;;;;GAMG;AACH;IAgBC;QAZQ,YAAO,GAAY,KAAK,CAAC;QAEjC;;6BAEqB;QACd,SAAI,GAAW,CAAC,CAAC;QAQvB,IAAI,CAAC,aAAa,GAAG,IAAI,GAAG,EAAwB,CAAC;QACrD,IAAI,CAAC,OAAO,GAAG,IAAI,GAAG,EAAwB,CAAC;IAChD,CAAC;IAEM,4BAAO,GAAd;QACC,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;QACrB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QACnB,IAAI,CAAC,KAAK,EAAE,CAAC;IACd,CAAC;IAgCD;;;OAGG;IACI,8BAAS,GAAhB;QACC,OAAO,IAAI,CAAC,OAAO,CAAC;IACrB,CAAC;IAEM,+BAAU,GAAjB,UAAkB,OAAgB;QACjC,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;IACxB,CAAC;IAEM,oCAAe,GAAtB,UAAuB,GAAW,EAAE,KAAU;QAC7C,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAA;IACnC,CAAC;IAEM,uCAAkB,GAAzB,UAA0B,GAAW;QACpC,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;IAChC,CAAC;IAEM,8BAAS,GAAhB,UAAiB,GAAW,EAAE,KAAU;QACvC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;IAC9B,CAAC;IACM,iCAAY,GAAnB,UAAoB,GAAW;QAC9B,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;IAC1B,CAAC;IACD,sBAAW,qCAAa;aAAxB;YACC,OAAO,IAAI,CAAC,aAAa,CAAC;QAC3B,CAAC;;;OAAA;IACD,sBAAW,+BAAO;aAAlB;YACC,OAAO,IAAI,CAAC,OAAO,CAAC;QACrB,CAAC;;;OAAA;IACF,iBAAC;AAAD,CAzFA,AAyFC,IAAA;AAzFqB,gCAAU","file":"","sourceRoot":"/","sourcesContent":["import Entity from \"../../../../goap/Entity\";\r\nimport { VGameObject } from \"../../base/VGameObject\";\r\nimport { ActionStatus } from \"./ActionStatus\";\r\nimport { GoapAgent } from \"./GoapAgent\";\r\nimport { IGoap } from \"./IGoap\";\r\n\r\n/*\r\n * @Description: \r\n * @Author: RannarYang \r\n * @Date: 2018-09-06 00:09:26 \r\n * @Last Modified by:   RannarYang \r\n * @Last Modified time: 2018-09-06 00:09:26 \r\n */\r\nexport abstract class GoapAction {\r\n\tprivate preconditions: Map<ActionStatus, Object>;\r\n\tprivate effects: Map<ActionStatus, Object>;\r\n\r\n\tprivate inRange: boolean = false;\r\n\r\n\t/* 执行动作的成本。\r\n\t* 找出适合动作的重量。\r\n\t* 更改它将影响在计划期间选择的操作。*/\r\n\tpublic cost: number = 1;\r\n\r\n\r\n\t/**\r\n\t* 一个动作通常必须在一个对象上执行。这就是那个对象。可以为空。 */\r\n\tpublic target: VGameObject;\r\n\r\n\tpublic constructor() {\r\n\t\tthis.preconditions = new Map<ActionStatus, Object>();\r\n\t\tthis.effects = new Map<ActionStatus, Object>();\r\n\t}\r\n\r\n\tpublic doReset() {\r\n\t\tthis.inRange = false;\r\n\t\tthis.target = null;\r\n\t\tthis.reset();\r\n\t}\r\n\t/**\r\n\t * Reset any variables that need to be reset before planning happens again.\r\n\t */\r\n\tabstract reset(): void;\r\n\r\n\t/**\r\n\t * Is the action done?\r\n\t */\r\n\tabstract isDone(): boolean;\r\n\r\n\t/**\r\n\t * Procedurally check if this action can run. Not all actions\r\n\t * will need this, but some might.\r\n\t */\r\n\tabstract checkProceduralPrecondition(agent: GoapAgent): boolean;\r\n\r\n\t/**\r\n\t * Run the action.\r\n\t * Returns True if the action performed successfully or false\r\n\t * if something happened and it can no longer perform. In this case\r\n\t * the action queue should clear out and the goal cannot be reached.\r\n\t */\r\n\tabstract perform(agent: GoapAgent): boolean;\r\n\r\n\t/**\r\n\t * Does this action need to be within range of a target game object?\r\n\t * If not then the moveTo state will not need to run for this action.\r\n\t */\r\n\tabstract requiresInRange(): boolean;\r\n\r\n\r\n\t/**\r\n\t * Are we in range of the target?\r\n\t * The MoveTo state will set this and it gets reset each time this action is performed.\r\n\t */\r\n\tpublic isInRange(): boolean {\r\n\t\treturn this.inRange;\r\n\t}\r\n\r\n\tpublic setInRange(inRange: boolean): void {\r\n\t\tthis.inRange = inRange;\r\n\t}\r\n\r\n\tpublic addPrecondition(key: string, value: any) {\r\n\t\tthis.preconditions.set(key, value)\r\n\t}\r\n\r\n\tpublic removePrecondition(key: string) {\r\n\t\tthis.preconditions.delete(key);\r\n\t}\r\n\r\n\tpublic addEffect(key: string, value: any) {\r\n\t\tthis.effects.set(key, value);\r\n\t}\r\n\tpublic removeEffect(key: string) {\r\n\t\tthis.effects.delete(key);\r\n\t}\r\n\tpublic get Preconditions() {\r\n\t\treturn this.preconditions;\r\n\t}\r\n\tpublic get Effects() {\r\n\t\treturn this.effects;\r\n\t}\r\n}"]}