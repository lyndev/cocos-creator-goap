{"version":3,"sources":["assets/src/app/ai/goap/GoapAction.ts"],"names":[],"mappings":";;;;;;;AAIA;;;;;;GAMG;AACH;IAgBC;QAZQ,YAAO,GAAY,KAAK,CAAC;QAEjC;;6BAEqB;QACd,SAAI,GAAW,CAAC,CAAC;QAQvB,IAAI,CAAC,aAAa,GAAG,IAAI,GAAG,EAAwB,CAAC;QACrD,IAAI,CAAC,OAAO,GAAG,IAAI,GAAG,EAAwB,CAAC;IAChD,CAAC;IAEM,4BAAO,GAAd;QACC,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;QACrB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QACnB,IAAI,CAAC,KAAK,EAAE,CAAC;IACd,CAAC;IAgCD;;;OAGG;IACI,8BAAS,GAAhB;QACC,OAAO,IAAI,CAAC,OAAO,CAAC;IACrB,CAAC;IAEM,+BAAU,GAAjB,UAAkB,OAAgB;QACjC,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;IACxB,CAAC;IAEM,oCAAe,GAAtB,UAAuB,GAAW,EAAE,KAAU;QAC7C,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAA;IACnC,CAAC;IAEM,uCAAkB,GAAzB,UAA0B,GAAW;QACpC,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;IAChC,CAAC;IAEM,8BAAS,GAAhB,UAAiB,GAAW,EAAE,KAAU;QACvC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;IAC9B,CAAC;IACM,iCAAY,GAAnB,UAAoB,GAAW;QAC9B,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;IAC1B,CAAC;IACD,sBAAW,qCAAa;aAAxB;YACC,OAAO,IAAI,CAAC,aAAa,CAAC;QAC3B,CAAC;;;OAAA;IACD,sBAAW,+BAAO;aAAlB;YACC,OAAO,IAAI,CAAC,OAAO,CAAC;QACrB,CAAC;;;OAAA;IACF,iBAAC;AAAD,CAzFA,AAyFC,IAAA;AAzFqB,gCAAU","file":"","sourceRoot":"/","sourcesContent":["import { VGameObject } from \"../../base/VGameObject\";\nimport { ActionStatus } from \"./ActionStatus\";\nimport { IGoap } from \"./IGoap\";\n\n/*\n * @Description: \n * @Author: RannarYang \n * @Date: 2018-09-06 00:09:26 \n * @Last Modified by:   RannarYang \n * @Last Modified time: 2018-09-06 00:09:26 \n */\nexport abstract class GoapAction {\n\tprivate preconditions: Map<ActionStatus, Object>;\n\tprivate effects: Map<ActionStatus, Object>;\n\n\tprivate inRange: boolean = false;\n\n\t/* 执行动作的成本。\n\t* 找出适合动作的重量。\n\t* 更改它将影响在计划期间选择的操作。*/\n\tpublic cost: number = 1;\n\n\t\n\t/**\n\t* 一个动作通常必须在一个对象上执行。这就是那个对象。可以为空。 */\n\tpublic target: VGameObject;\n\n\tpublic constructor() {\n\t\tthis.preconditions = new Map<ActionStatus, Object>();\n\t\tthis.effects = new Map<ActionStatus, Object>();\n\t}\n\n\tpublic doReset() {\n\t\tthis.inRange = false;\n\t\tthis.target = null;\n\t\tthis.reset();\n\t}\n\t/**\n\t * Reset any variables that need to be reset before planning happens again.\n\t */\n\tabstract reset(): void;\n\n\t/**\n\t * Is the action done?\n\t */\n\tabstract isDone(): boolean;\n\n\t/**\n\t * Procedurally check if this action can run. Not all actions\n\t * will need this, but some might.\n\t */\n\tabstract checkProceduralPrecondition(agent: VGameObject): boolean;\n\n\t/**\n\t * Run the action.\n\t * Returns True if the action performed successfully or false\n\t * if something happened and it can no longer perform. In this case\n\t * the action queue should clear out and the goal cannot be reached.\n\t */\n\tabstract perform(iGoap: IGoap): boolean;\n\n\t/**\n\t * Does this action need to be within range of a target game object?\n\t * If not then the moveTo state will not need to run for this action.\n\t */\n\tabstract requiresInRange(): boolean;\n\n\n\t/**\n\t * Are we in range of the target?\n\t * The MoveTo state will set this and it gets reset each time this action is performed.\n\t */\n\tpublic isInRange(): boolean {\n\t\treturn this.inRange;\n\t}\n\n\tpublic setInRange(inRange: boolean): void {\n\t\tthis.inRange = inRange;\n\t}\n\n\tpublic addPrecondition(key: string, value: any) {\n\t\tthis.preconditions.set(key, value)\n\t}\n\n\tpublic removePrecondition(key: string) {\n\t\tthis.preconditions.delete(key);\n\t}\n\n\tpublic addEffect(key: string, value: any) {\n\t\tthis.effects.set(key, value);\n\t}\n\tpublic removeEffect(key: string) {\n\t\tthis.effects.delete(key);\n\t}\n\tpublic get Preconditions() {\n\t\treturn this.preconditions;\n\t}\n\tpublic get Effects() {\n\t\treturn this.effects;\n\t}\n}"]}